on: push
name: Build Staging
jobs:
  build:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v3
      - name: setup dot env
        run: |
          mv src/.env.example src/.env
          echo '${{ secrets.DOT_ENV }}' >> src/.env
          cat src/.env
      - name: setup dockercompose
        run: |
          sed -i "s/STACKHERO_DOCKER_HOST/${{ secrets.STACKHERO_DOCKER_HOST }}/g" docker-compose.prod.yml
          cat docker-compose.prod.yml
      - name: view the secrets context
        shell: bash
        run: echo "$SECRETS_CONTEXT"
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}

      - uses: actions/setup-node@v3
        with:
          node-version: '16.17.0'
      - uses: "shivammathur/setup-php@v2"
        with:
          php-version: "latest"
      - name: Install composer dependencies
        uses: ramsey/composer-install@v2
        with:
          working-directory: "src"
      - name: Install node dependencies
        working-directory: ./src
        run: |
          npm install;
      - name: Build vite
        run: |
          cd ./src
          ls resources/js/Components
          npm run build
      - name: Deploy
        run: |
          set -x
          #set up credentials to remote docker
          cd /tmp/
          curl -o certificates.tar https://docker:${{ secrets.STACKHERO_DOCKER_CERTIFICATES_PASSWORD }}@${{ secrets.STACKHERO_DOCKER_HOST }}/stackhero/docker/certificates.tar
          tar -xf certificates.tar
          (docker context rm -f ${{ secrets.STACKHERO_DOCKER_HOST }} 2> /dev/null || true)
          docker context create ${{ secrets.STACKHERO_DOCKER_HOST }} --description "${{ secrets.STACKHERO_DOCKER_SERVICE_ID }} (${{ secrets.STACKHERO_DOCKER_HOST }})" --docker "host=tcp://${{ secrets.STACKHERO_DOCKER_HOST }}:2376,ca=ca.pem,cert=cert.pem,key=key.pem"
          cd ${{ github.workspace }}
          docker context use ${{ secrets.STACKHERO_DOCKER_HOST }}

          #zero downtime deployment
          service_name=app
          old_container_id=$(docker ps -f name=$service_name -q | tail -n1)
          # bring a new container online, running new code
          # (nginx continues routing to the old container only)
          docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps --scale $service_name=2 --no-recreate $service_name

          # wait for new container to be available
          new_container_id=$(docker ps -f name=$service_name -q | head -n1)
          new_container_ip=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $new_container_id)
          curl --silent --include --retry-connrefused --retry 30 --retry-delay 1 --fail http://$new_container_ip:3000/ || exit 1

          # reload nginx
          # start routing requests to the new container (as well as the old)
          docker exec web /usr/sbin/nginx -s reload

          docker stop $old_container_id
          docker rm $old_container_id

          docker-compose up -d --no-deps --scale $service_name=1 --no-recreate $service_name

          # reload nginx
          # stop routing requests to the old container
          docker exec web /usr/sbin/nginx -s reload

          #start up the other containers
          docker-compose -f docker-compose.yml -f docker-compose.prod.yml up


          #clean up
          docker image prune -f
      - name: Run migrations
        run: |
          #check for migrations
          docker-compose exec -T app php artisan migrate:status

          #run migrations
          docker-compose exec -T app php artisan migrate
